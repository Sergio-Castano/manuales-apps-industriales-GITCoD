Elementos y Conexiones
   -
Redactar los elementos (ESP32, BioAmp Exg Pill, electrodos, cables, protoboard/pcb, bateria) que se necesitan

mas info y conexiones del BioAmp Exg Pill: https://www.crowdsupply.com/upside-down-labs/bioamp-exg-pill

poner diagrama de las conexiones y explcarlas (electrodos tambien)

Poner foto del montaje total (electrodos tambien)


Configuración y Codigo en Arduino
   -
Explicacion de la configuracion con pantallazos:
1. Conectar la ESP32 al PC (Cable USB a Micro USB)
2. Entrar a Arduino IDE y escoger el puerto USB en el que se encuentre la ESP32 en cuestión
3. Seleccionar la placa ESP32 que se este usando, en el caso de no tener las tarjetas de ESP32, seguir este tutorial: [Tutorial ESP32 y Arduino IDE]
4. Cargar el siguiente codigo en un nuevo archivo de arduino, con este codigo se testeará que el BioAmp Exg Pill funcione correctamente
  ```cpp
// EMG Envelop - BioAmp EXG Pill
// https://github.com/upsidedownlabs/BioAmp-EXG-Pill

// Upside Down Labs invests time and resources providing this open source code,
// please support Upside Down Labs and open-source hardware by purchasing
// products from Upside Down Labs!

// Copyright (c) 2021 Upside Down Labs - contact@upsidedownlabs.tech

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#define SAMPLE_RATE 500
#define BAUD_RATE 115200
#define INPUT_PIN 34
#define BUFFER_SIZE 128

int circular_buffer[BUFFER_SIZE];
int data_index, sum;

void setup() {
  Serial.begin(BAUD_RATE);
}

void loop() {
  // Calculate elapsed time
  static unsigned long past = 0;
  unsigned long present = micros();
  unsigned long interval = present - past;
  past = present;

  // Run timer
  static long timer = 0;
  timer -= interval;

  // Sample and get envelop
  if (timer < 0) {
    timer += 1000000 / SAMPLE_RATE;
    int sensor_value = analogRead(INPUT_PIN);
    float signal = EMGFilter(sensor_value);
    int envelop = getEnvelop(abs(signal));
    float envolvente = filtro_pasa_bajos(abs(signal));
    int lim = 1200;
    Serial.print(lim);
    Serial.print(",");
    Serial.print(lim * -1);
    Serial.print(",");
    Serial.print(signal);
    Serial.print(",");
    Serial.println(envolvente*4);
  }
}

// Envelop detection algorithm
int getEnvelop(int abs_emg) {
  sum -= circular_buffer[data_index];
  sum += abs_emg;
  circular_buffer[data_index] = abs_emg;
  data_index = (data_index + 1) % BUFFER_SIZE;
  return (sum / BUFFER_SIZE) * 2;
}

float filtro_pasa_bajos(float entrada) {
  static float Vin, Vin_m_1, Vo_m_1;
  Vin = entrada;
  float Vo = (0.03046 * Vin) + (0.03046 * Vin_m_1) + (0.9391 * Vo_m_1);
  Vin_m_1 = Vin;
  Vo_m_1 = Vo;
  return Vo;
}

// Band-Pass Butterworth IIR digital filter, generated using filter_gen.py.
// Sampling rate: 500.0 Hz, frequency: [74.5, 149.5] Hz.
// Filter is order 4, implemented as second-order sections (biquads).
// Reference:
// https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
// https://courses.ideate.cmu.edu/16-223/f2020/Arduino/FilterDemos/filter_gen.py
float EMGFilter(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - 0.05159732 * z1 - 0.36347401 * z2;
    output = 0.01856301 * x + 0.03712602 * z1 + 0.01856301 * z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -0.53945795 * z1 - 0.39764934 * z2;
    output = 1.00000000 * x + -2.00000000 * z1 + 1.00000000 * z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - 0.47319594 * z1 - 0.70744137 * z2;
    output = 1.00000000 * x + 2.00000000 * z1 + 1.00000000 * z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -1.00211112 * z1 - 0.74520226 * z2;
    output = 1.00000000 * x + -2.00000000 * z1 + 1.00000000 * z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}
```
Con este codigo corriendo verifica el serial plotter de arduino y se deben ver unas señales de la siguiente manera, la cual debe de variar cada vez que se realiza un estimulo en los electrodos:

![Test_EMG_Signals](Nodos Inalámbricos/imgs/Test_EMG_Signals.png)

5. una vez sabemos que todo esta funcionando correctamente cargamos el siguiente codigo en la ESP32 para que transmita por medio de MQTT los datos:
  ```cpp
INSERTE EL CODIGO AQUI DE "EMG_FINAL_MQTT"
```
  recordar cambiar algunos parametros iniciales como IP del broker, topic a publicar, topic a suscribirse, red wifi a conectarse y ID del cliente ante el broker

  Listo el EMG esta transmitiendo por medio de MQTT una vez reciba la señal!








  [Tutorial ESP32 y Arduino IDE]: https://randomnerdtutorials.com/installing-the-esp32-board-in-arduino-ide-windows-instructions/
